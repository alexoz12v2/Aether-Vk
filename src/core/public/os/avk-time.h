#pragma once

#include <atomic>
#include <cstdint>

namespace avk::os {

using timeus_t = int64_t;

/// Time information generated by the `TimeInfo` class
/// `FixedDeltaTime`, `TimeScale` are not here because you can take them
/// from the `TimeInfo` class
struct TimeReadings {
  /// microseconds in simulation time since instantiation of `TimeInfo` which
  /// created this object
  timeus_t Time;
  /// microseconds in simulation time since the last fixed update of `TimeInfo`
  /// which created this object
  timeus_t FixedTime;
  /// microseconds in simulation time since last update of `TimeInfo` which
  /// created this object
  timeus_t DeltaTime;
  /// microseconds in monotonic real time since instantiation of `TimeInfo`
  /// which created this object
  timeus_t UnscaledTime;
  /// microseconds in monotonic real time since last update of `TimeInfo` which
  /// created this object
  timeus_t UnscaledDeltaTime;
  /// microseconds in simulation time since last update, smoothed out by the
  /// last 4 DeltaTimes with a alpha=0.5 Exponentially Moving Average
  timeus_t SmoothDeltaTime;
};

/// Time information class inspired by the Unity Game Engine
/// All integers here are in microseconds
/// we refer to
/// - "real time": Raw Monotonic count in microseconds since class instantiation
/// - "simulation time": Scaled and Capped Real Time
///   - Scaled by `TimeScale`
///   - Capped by `MaximumDeltaTime`
/// - "fixed time": microseconds since class instantiation in which last fixed
///   update function call happened
class TimeInfo {
 public:
  static uint32_t constexpr DeltasWindowCount = 4;

  TimeInfo(timeus_t fixedDeltaTime, timeus_t maximumDeltaTime,
           float timeScale) noexcept;

  /// updates the real time and simulation time by acquiring the latest
  /// monotonic CPU timestamp
  /// \note called by update thread only
  void UTupdate();

  /// update fixed time by adding to it a `FixedDeltaTime`
  /// \note called by update thread only
  void UTfixedUpdate();

  /// checks whether `FixedTime` is behind `Time` by at least one
  /// `FixedDeltaTime`.
  /// \note we are not comparing with `UnscaledTime`, because we don't want
  /// physical simulation to cause additional lag in case of capped deltas
  bool needsFixedUpdate() const;

  /// thread safe as it doesn't modify anything about this class
  TimeReadings current() const;

  /// indicated frequency of fixed update (accuracy of physical simulation)
  /// \warning should be smaller than `MaximumDeltaTime`
  std::atomic<timeus_t> FixedDeltaTime;

  /// should never be set to a zero or negative value
  /// \warning should be higher than `FixedDeltaTime`
  std::atomic<timeus_t> MaximumDeltaTime;

  /// should never be set to a negative value
  std::atomic<float> TimeScale;

 private:
  /// monotonic time at the last fixed update
  std::atomic<int64_t> m_lastFixedUpdate = 0;

  /// monotonic real time at the last update
  std::atomic<int64_t> m_lastRealUpdate = 0;

  /// simulation time at the last update
  std::atomic<int64_t> m_lastUpdate = 0;

  /// Windows QPC function returns its value in CPU cycles,
  /// hence the need to know the CPU frequency
  [[maybe_unused]] int64_t m_frequency = 0;

  /// CPU monotonic time at class instantiation. It represents the
  /// "zero" in the `Time` method "coordinate system"
  int64_t m_start = 0;

  /// Window of last 4 delta times to compute a smoothed out delta time
  /// the current element is extracted as `DeltaTime`
  timeus_t m_deltas[DeltasWindowCount]{};

  /// current value for `UnscaledDeltaTime`
  std::atomic<timeus_t> m_lastRawDelta = 0;

  /// Index inside the deltas circular ring
  /// always read before reading array and updated after writing into array
  std::atomic<int32_t> m_deltasIndex = 0;
};

}  // namespace avk::os